name: deployer

on:
  push:
    paths:
      - ".github/workflows/deployer.yml"
  workflow_dispatch: # manual

jobs:
  # predeploy:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - run: echo building
  #     - run: echo "BUTLER_MODEL= ${{ vars.BUTLER_MODEL}}"
  #     # - run: echo "DEPLOY_KEY= ${{ secrets.DEPLOY_KEY }}" # warning if try to include this
  generate:
    runs-on: ubuntu-latest
    steps:
      - run: echo "RANDOM_PASS=$(LC_ALL=C tr -dc A-Za-z0-9 </dev/urandom | head -c 12)" >> $GITHUB_ENV # use outputs?
      - run: env

  testing:
    # needs: predeploy
    # environment: staging
    runs-on: ubuntu-latest
    container:
      image: mysql:5.7 # TODO client only image?
    services:
      mysqlserver:
        image: mysql:5.7
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: foothebar
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping" --health-interval=10s --health-timeout=5s --health-retries=3
    steps:
      - run: env
      # - run: mysql --version
      - run: mysql -h mysqlserver -u root -proot -e "SHOW DATABASES;"
      - run: echo "job.services= ${{ toJson(job.services)}}" # { mysql: { id, ports:[], network } }
      - run: echo "job.container= ${{ toJson(job.container)}}" # {id, network }
      # FYI alternative is just use docker compose to orchestrate it all for you and plug it into a step, and the reason I suggest that is b/c you can run it locally and test it w/o pushing or using smth like act, but YMMV so service containers exist too

  # deploy:
  #   needs: predeploy
  #   runs-on: ubuntu-latest
  #   environment: production

  # deploy:
  #   needs: predeploy
  #   runs-on: ubuntu-latest
  #   environment: production

  #   steps:
  #     - run: echo "BUTLER_MODEL= ${{ vars.BUTLER_MODEL}}"
  #     - run: echo "DEPLOY_KEY= ${{ secrets.DEPLOY_KEY }}" # i.e. defined only in prod/stating
  #     - run: echo "deploying"
  #     - run: echo "deployed"
